import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const gamesRoot = path.resolve(__dirname, '../../src/games');

const outputFiles = {
    data: path.join(gamesRoot, 'manifest.generated.ts'),
    client: path.join(gamesRoot, 'manifest.client.generated.tsx'),
    server: path.join(gamesRoot, 'manifest.server.generated.ts'),
};

const fileExists = async (filePath) => {
    try {
        await fs.access(filePath);
        return true;
    } catch {
        return false;
    }
};

const toImportPath = (relativePath) => {
    const normalized = relativePath.split(path.sep).join('/');
    const withoutExt = normalized.replace(/\.(ts|tsx)$/, '');
    return `./${withoutExt}`;
};

const readManifestMeta = async (manifestPath) => {
    const content = await fs.readFile(manifestPath, 'utf8');
    const idMatch = content.match(/id\s*:\s*['"`]([^'"`]+)['"`]/);
    const typeMatch = content.match(/type\s*:\s*['"`](game|tool)['"`]/);
    const enabledMatch = content.match(/enabled\s*:\s*(true|false)/);
    if (!idMatch || !typeMatch || !enabledMatch) {
        throw new Error(`[Manifest] 无法解析 manifest: ${manifestPath}`);
    }
    return {
        id: idMatch[1],
        type: typeMatch[1],
        enabled: enabledMatch[1] === 'true',
    };
};

const collectGameEntries = async () => {
    const dirents = await fs.readdir(gamesRoot, { withFileTypes: true });
    const entries = [];

    for (const dirent of dirents) {
        if (!dirent.isDirectory()) continue;
        const dirName = dirent.name;
        if (dirName.startsWith('.')) continue;

        const dirPath = path.join(gamesRoot, dirName);
        const manifestPath = path.join(dirPath, 'manifest.ts');
        if (!(await fileExists(manifestPath))) {
            continue;
        }

        const meta = await readManifestMeta(manifestPath);
        if (meta.id !== dirName) {
            throw new Error(`[Manifest] manifest.id 与目录名不一致: ${dirName} (${meta.id})`);
        }

        const gamePath = path.join(dirPath, 'game.ts');
        const boardPath = path.join(dirPath, 'Board.tsx');
        const tutorialPath = path.join(dirPath, 'tutorial.ts');
        const thumbnailPath = path.join(dirPath, 'thumbnail.tsx');

        const hasGame = await fileExists(gamePath);
        const hasBoard = await fileExists(boardPath);
        const hasTutorial = await fileExists(tutorialPath);
        const hasThumbnail = await fileExists(thumbnailPath);

        if (meta.type === 'game' && (!hasGame || !hasBoard)) {
            throw new Error(`[Manifest] 游戏缺少实现: ${dirName} (game.ts/Board.tsx)`);
        }

        entries.push({
            id: meta.id,
            type: meta.type,
            enabled: meta.enabled,
            dirName,
            manifestImport: toImportPath(path.relative(gamesRoot, manifestPath)),
            gameImport: hasGame ? toImportPath(path.relative(gamesRoot, gamePath)) : null,
            boardImport: hasBoard ? toImportPath(path.relative(gamesRoot, boardPath)) : null,
            tutorialImport: hasTutorial ? toImportPath(path.relative(gamesRoot, tutorialPath)) : null,
            thumbnailImport: hasThumbnail ? toImportPath(path.relative(gamesRoot, thumbnailPath)) : null,
        });
    }

    return entries.sort((a, b) => a.id.localeCompare(b.id));
};

const buildDataManifestFile = ({ entries, outputPath }) => {
    const lines = [];
    lines.push('/* eslint-disable */');
    lines.push(`// AUTO-GENERATED by scripts/game/generate_game_manifests.js. DO NOT EDIT.`);
    lines.push(`import type { GameManifestEntry } from './manifest.types';`);
    lines.push('');
    entries.forEach((entry, index) => {
        lines.push(`import entry${index} from '${entry.manifestImport}';`);
    });
    lines.push('');
    lines.push('export const GAME_MANIFEST: GameManifestEntry[] = [');
    entries.forEach((_, index) => {
        lines.push(`    entry${index},`);
    });
    lines.push('];');
    lines.push('');
    lines.push('export const GAME_MANIFEST_BY_ID: Record<string, GameManifestEntry> = Object.fromEntries(');
    lines.push('    GAME_MANIFEST.map((entry) => [entry.id, entry])');
    lines.push(');');
    lines.push('');

    return fs.writeFile(outputPath, lines.join('\n'), 'utf8');
};

const buildClientManifestFile = ({ entries, outputPath }) => {
    const lines = [];
    lines.push('/* eslint-disable */');
    lines.push(`// AUTO-GENERATED by scripts/game/generate_game_manifests.js. DO NOT EDIT.`);
    lines.push(`import type { GameClientManifestEntry } from './manifest.client.types';`);
    lines.push(`import { ManifestGameThumbnail } from '../components/lobby/thumbnails';`);
    lines.push('');

    entries.forEach((entry, index) => {
        lines.push(`import manifest${index} from '${entry.manifestImport}';`);
        if (entry.gameImport) {
            lines.push(`import Game${index} from '${entry.gameImport}';`);
        }
        if (entry.boardImport) {
            lines.push(`import Board${index} from '${entry.boardImport}';`);
        }
        if (entry.tutorialImport) {
            lines.push(`import Tutorial${index} from '${entry.tutorialImport}';`);
        }
        if (entry.thumbnailImport) {
            lines.push(`import Thumbnail${index} from '${entry.thumbnailImport}';`);
        }
        lines.push('');
    });

    entries.forEach((entry, index) => {
        lines.push(`const entry${index}: GameClientManifestEntry = {`);
        lines.push(`    manifest: manifest${index},`);
        if (entry.gameImport) {
            lines.push(`    game: Game${index},`);
        }
        if (entry.boardImport) {
            lines.push(`    board: Board${index},`);
        }
        if (entry.tutorialImport) {
            lines.push(`    tutorial: Tutorial${index},`);
        }
        if (entry.thumbnailImport) {
            lines.push(`    thumbnail: <Thumbnail${index} />,`);
        } else {
            lines.push(`    thumbnail: <ManifestGameThumbnail manifest={manifest${index}} />,`);
        }
        lines.push('};');
        lines.push('');
    });

    lines.push('export const GAME_CLIENT_MANIFEST: GameClientManifestEntry[] = [');
    entries.forEach((_, index) => {
        lines.push(`    entry${index},`);
    });
    lines.push('];');
    lines.push('');
    lines.push('export const GAME_CLIENT_MANIFEST_BY_ID: Record<string, GameClientManifestEntry> = Object.fromEntries(');
    lines.push('    GAME_CLIENT_MANIFEST.map((entry) => [entry.manifest.id, entry])');
    lines.push(');');
    lines.push('');

    return fs.writeFile(outputPath, lines.join('\n'), 'utf8');
};

const buildServerManifestFile = ({ entries, outputPath }) => {
    const lines = [];
    lines.push('/* eslint-disable */');
    lines.push(`// AUTO-GENERATED by scripts/game/generate_game_manifests.js. DO NOT EDIT.`);
    lines.push(`import type { GameServerManifestEntry } from './manifest.server.types';`);
    lines.push('');

    entries.forEach((entry, index) => {
        lines.push(`import manifest${index} from '${entry.manifestImport}';`);
        lines.push(`import Game${index} from '${entry.gameImport}';`);
    });
    lines.push('');

    entries.forEach((_, index) => {
        lines.push(`const entry${index}: GameServerManifestEntry = {`);
        lines.push(`    manifest: manifest${index},`);
        lines.push(`    game: Game${index},`);
        lines.push('};');
        lines.push('');
    });

    lines.push('export const GAME_SERVER_MANIFEST: GameServerManifestEntry[] = [');
    entries.forEach((_, index) => {
        lines.push(`    entry${index},`);
    });
    lines.push('];');
    lines.push('');
    lines.push('export const GAME_SERVER_MANIFEST_BY_ID: Record<string, GameServerManifestEntry> = Object.fromEntries(');
    lines.push('    GAME_SERVER_MANIFEST.map((entry) => [entry.manifest.id, entry])');
    lines.push(');');
    lines.push('');

    return fs.writeFile(outputPath, lines.join('\n'), 'utf8');
};

const run = async () => {
    const entries = await collectGameEntries();
    const serverEntries = entries.filter((entry) => entry.type === 'game' && entry.gameImport);

    await buildDataManifestFile({ entries, outputPath: outputFiles.data });
    await buildClientManifestFile({ entries, outputPath: outputFiles.client });
    await buildServerManifestFile({ entries: serverEntries, outputPath: outputFiles.server });

    console.log('[Manifest] Generated manifests:');
    console.log(`- ${path.relative(process.cwd(), outputFiles.data)}`);
    console.log(`- ${path.relative(process.cwd(), outputFiles.client)}`);
    console.log(`- ${path.relative(process.cwd(), outputFiles.server)}`);
};

run().catch((error) => {
    console.error('[Manifest] Generation failed:', error);
    process.exit(1);
});

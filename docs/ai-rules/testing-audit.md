# 测试与审计规范

> 本文档定义测试策略、审计工具使用和质量保证流程。**触发条件**：新增功能/技能/API、修复 bug、审查实现完整性时阅读。

---

## 测试策略总览

**GameTestRunner 行为测试是最优先、最可靠的测试手段**，审计工具是补充。

| 工具 | 适用场景 |
|------|---------|
| GameTestRunner | 命令序列+状态断言（首选） |
| entityIntegritySuite | 数据定义契约（注册表/引用链/触发路径/效果/i18n） |
| referenceValidator | 实体引用链提取与验证 |
| interactionChainAudit | UI 状态机 payload 覆盖（模式 A） |
| interactionCompletenessAudit | Interaction handler 注册覆盖（模式 B） |

**新游戏选型**：所有游戏必选 GameTestRunner；≥20 实体 → entityIntegritySuite；有多步 UI 交互 → interactionChainAudit；有 InteractionSystem → interactionCompletenessAudit。

---

## 效果数据契约测试（强制）

> 新增游戏/英雄/卡牌/Token 定义时，必须同步编写契约测试。

**契约测试的职责**：
1. **结构完整性**：字段存在、引用不断裂、格式正确
2. **语义正确性**：目标合法性、数值范围、枚举值合法性

**数据结构完整性原则（强制）**：
- 数据定义必须包含所有执行所需的字段，禁止在执行层"猜测"缺失信息
- 契约测试必须检查数据语义正确性，不只是字段存在性

### `createEffectContractSuite<TSource, TEffect>` 工厂

接受 `getSources()` / `getSourceId()` / `extractEffects()` / `rules: EffectContractRule[]` / `minSourceCount`。

每条 `EffectContractRule` 定义：`name` / `appliesTo(effect)` / `check(effect)` / `describeViolation(effect)`。

### `createI18nContractSuite<TSource>` 工厂

验证 i18n key 格式（正则）和存在性（各语言文件）。接受 `keyExtractors` + `locales`。

### 强制要求

- 新增实体 → 确保现有契约规则覆盖，运行测试
- 新增效果类型 → 评估是否需新增契约规则
- 新增游戏 → 创建 `entity-chain-integrity.test.ts` 并注册契约规则
- 所有有 action 的效果必须声明 timing

---

## 交互链完整性审计 — 模式 A：UI 状态机（强制）

> 多步交互（UI ≥2 步输入构建 payload）必须声明 `interactionChain`。

### 核心类型（`engine/primitives/ability.ts`）

```typescript
interface InteractionStep { step: string; inputType: 'unit'|'position'|'card'|'direction'|'choice'|'cards'; producesField: string; optional?: boolean; }
interface PayloadContract { required: string[]; optional?: string[]; }
interface InteractionChain { steps: InteractionStep[]; payloadContract: PayloadContract; }
```

### 三类检查

| 检查 | 检测的 bug |
|------|-----------|
| 声明完整性：多步技能是否都声明了 `interactionChain` | 新增多步技能忘记声明 |
| 步骤覆盖：steps 产出 ⊇ payloadContract.required | UI 缺少某个交互步骤 |
| 契约对齐：定义层与执行器的 payloadContract 双向一致 | 两端字段不同步 |

---

## 交互完整性审计 — 模式 B：Interaction 链（强制）

> 使用 InteractionSystem 的游戏必须创建此审计。

### 三类检查

| 检查 | 检测的 bug |
|------|-----------|
| Handler 注册覆盖：所有 sourceId 都有对应 handler | 创建了交互但没注册处理函数 |
| 链式完整性：handler 产出的后续 sourceId 也有 handler | 多步链中间断裂 |
| 孤儿 Handler：注册了 handler 但无能力引用 | 死代码/重构遗留 |

### 审计输入自动抽取（P0 强制）

禁止长期维护超长手工列表。审计输入应从源码自动抽取（静态分析 `createSimpleChoice`/`registerInteractionHandler` 调用）。动态 `sourceId`（非字面量）视为审计风险，必须改成可静态分析或补充白名单。

**模式 A vs B**：A 检查 UI payload 字段覆盖，B 检查 handler 注册覆盖。一个游戏可同时使用两种。

---

## CI 质量门禁（P0）

PR 必跑并阻断合并：`typecheck` → `test:games` → `i18n:check` → `test:e2e:critical`。

---

## 描述→实现全链路审查规范（强制）

> **当用户说"审查"/"审核"/"检查实现"/"核对"等词时，必须按此规范执行，禁止凭印象回答。**

### 适用场景

① 新增技能/效果/事件卡/被动/光环实现 ② 修复"没效果"类 bug ③ 审查已有机制 ④ 重构涉及消费链路

### 审查流程

**第零步：锁定权威描述** — 权威来源按可信度排序：① **用户在当前对话中明确给出的描述**（最高优先级）→ ② **`src/games/<gameId>/rule/*.md` 中已录入的规则文本**（经用户确认的录入产物）→ ③ **卡牌实物图片**（需辨认，看不清时必须停止并向用户确认）。**禁止将以下来源作为权威输入**：i18n JSON、AbilityDef.description、代码注释——这些是实现产物，可能已经带着错误理解。当不同来源冲突时，以用户明确给出的为准；有任何疑问时必须向用户确认后再开始。

**第一步：拆分独立交互链** — 审查的原子单位是**独立交互链**，不是"卡牌"或"技能"。任何需要独立触发条件、玩家输入、或状态变更路径的效果，都必须作为单独的审查条目。

拆分信号：
- 不同的触发时机（"打出时" vs "之后每当…时"）
- 需要玩家做出新的选择
- 独立的条件→结果对
- **"可以/可选"语义**：描述中"你可以"/"may"必须作为独立交互链，实现必须包含确认/跳过 UI，禁止自动执行
- **"代替 X 做 Y"语义**：必须拆为两个原子操作——"消耗 X 的资源/机会"和"执行 Y 的效果"

**作用目标语义边界锁定（强制）**：拆解每个原子步骤时，**作用目标（名词）的语义边界必须精确锁定**：
- **无限定词 = 不区分**："士兵"/"单位"/"卡牌" = 所有，包括敌我双方
- **有限定词 = 严格过滤**："敌方士兵"/"友方单位"/"你的卡牌" = 仅限定范围
- **禁止凭"游戏常识"或"设计直觉"自行添加描述中不存在的限定条件**
- **审查时**：对实现中每个 filter/条件表达式，回溯到权威描述确认该过滤条件有描述依据。实现中存在但描述中不存在的过滤条件 = ❌

**第一步自检（强制）**：拆分完成后，将所有交互链描述拼接，与原文逐句对照。原文中每一句话都必须被至少一条链覆盖，否则禁止进入第二步。

> **常见遗漏模式**：
> - 只审查"即时效果"，遗漏"持续/触发效果"（后者往往是完整的独立交互链）
> - 限定条件被全局化实现丢失：描述含限定词但实现使用不携带约束的全局机制，审计时看到"有前置检查+有额度增加"容易误判为 ✅，必须追问"额度使用时限定条件是否仍被强制执行"
> - "代替"类描述只实现了替代效果，遗漏了被代替资源的机会成本消耗
> - **实现自行添加描述中不存在的限定条件**：描述说"士兵"（无敌我限定），实现加了 `owner !== xxx` 只作用于敌方。测试按错误理解编写后，语义错误被固化。审查时必须逐个 filter 回溯描述依据

**第二步：逐链追踪八层**

| 层 | 检查内容 |
|----|----------|
| 1. 定义层 | 效果在数据定义中声明，字段值与权威描述一致 |
| 2. 注册层 | 定义已注册到对应 registry，白名单/映射表已同步更新 |
| 3. 执行层 | 触发/执行逻辑存在且语义一致。**限定条件全程约束**：描述中的限定词是否在执行路径全程被强制约束？仅在入口检查但执行时不约束 = ❌。**隐含代价**："代替 X"/"消耗 X 来做 Y"的两个原子操作都必须有对应事件和状态变更。 |
| 4. 状态层 | 状态变更被 reduce 正确持久化。技能声明的所有代价（资源消耗/行动消耗/自伤等）都有对应的 reduce 处理。 |
| 5. 验证层 | 是否影响其他命令合法性。**额度/权限泄漏**：效果给出的额度/权限，玩家能否绕过描述中的限定条件使用？ |
| 6. UI 层 | 视觉反馈/交互入口/状态提示同步。**统一查询入口**：UI 层动态数值禁止直接读底层字段。**交互模式注册**：新增的交互等待状态是否已注册到自动跳过守卫？遗漏会导致等待玩家输入时阶段被自动跳过。 |
| 7. i18n 层 | 所有面向玩家的文本在全部语言文件中有对应条目 |
| 8. 测试层 | 端到端测试覆盖"触发→生效→状态正确" |

**第三步：grep 发现所有消费点** — ID 只出现在定义+注册文件 = 消费层缺失。

**第四步：交叉影响检查** — 新增的交互链是否会触发已有机制的连锁反应。列出可能的连锁路径，确认已有机制能正确响应或显式声明不触发。

### 测试覆盖要求

每条交互链：正向（触发→生效→验证状态）+ 负向（不触发→状态未变）+ 边界（0值/空目标/多次叠加）。

- **事件发射 ≠ 状态生效**，必须同时断言 reduce 后的最终状态
- **"可以/可选"效果**：正向（确认→生效）+ 负向（跳过→不生效）+ 验证（条件不满足→拒绝）
- 禁止只测注册/写入就判定"已实现"

### 产出要求

- 输出"独立交互链 × 八层"矩阵，每条链附带权威描述原文
- 每个交叉点 ✅/❌ + 具体证据（文件名+函数名）
- ❌ 时立即修复或标注 TODO
- 禁止"看起来没问题"的模糊结论

---

## 数据查询一致性审查（强制）

> 纵向链路（定义→注册→执行→状态→…）完整，不代表实现完整——消费点绕过统一查询入口是最常见的"没效果"根因。

**审查方法**：

1. **识别统一查询入口**：每个可被动态修改的属性都有"正确的查询方式"（如通过函数获取而非直接读字段）。审查时必须明确列出。

2. **grep 原始字段访问**：搜索所有直接访问底层数据的代码，排除合法场景（查询函数内部、不受该机制影响的场景）后，剩余的都是绕过嫌疑。

3. **逐个判定**：该查询结果是否会因 buff/共享/临时效果而改变？→ 是 → 必须走统一入口。只关心"印刷值"？→ 可以直接访问。

4. **输出绕过清单**：文件+行号+当前代码+应改为。

**典型绕过模式**：

| 绕过模式 | 影响 |
|----------|------|
| 直接读实体的原始属性字段用于计算/判定 | buff/光环/共享/临时效果不生效 |
| 检查其他实体的属性时绕过统一入口 | 其他实体的动态效果不生效 |
| UI 层直接读底层字段显示数值 | 动态修正不反映在界面上 |

**适用时机**：新增"修改/增强/共享"类机制时、修复"没效果"类 bug 后、重构数据查询入口时。**grep 范围必须包含 `.tsx` 文件**。

---

## 元数据语义一致性审计（强制）

> 注册完整性审计只检查"是否注册了"，不检查"元数据声明是否与实际行为一致"。元数据被下游逻辑消费时，语义错误会导致静默的逻辑分支错误。

### 核心原则

**handler/执行器的元数据声明（categories/tags/meta）必须与其实际输出一致**。下游逻辑依赖元数据做分支判断时，声明缺失会导致分支被跳过。

### 审计方法

1. **自动化审计**：对每个注册的 handler 调用（mock 状态），检查输出事件类型是否与元数据声明一致
2. **反向检查**：声明了某 category 但 handler 未产生对应事件 → 声明过度或 mock 不足
3. **适用时机**：新增/修改 handler 时（强制）；修复"某阶段被跳过"/"效果未触发"类 bug 时

---

## 效果语义一致性审查（强制）

> 审计不能只检查"有没有产生正确类型的事件"，还必须检查"事件的产生方式是否与规则描述的机制一致"。测试按错误实现编写时，测试通过 ≠ 实现正确。

### 审查方法

1. **锁定权威描述**：特别关注"如何计算"的部分（数据来源、计算公式、触发条件）

2. **语义拆解**，重点关注：
   - **数据来源**：效果读取的数据从哪里来？（已有状态 vs 额外随机、当前状态 vs 快照）
   - **计算方式**：数值如何计算？（动态计算 vs 固定值）
   - **作用目标**：效果作用于谁？（自身 vs 对手）
   - **作用目标语义边界（强制）**：描述中每个名词的语义边界必须精确锁定。**无限定词 = 不区分**，有限定词 = 严格过滤。具体规则：
     - "士兵"/"单位"/"卡牌" = 所有，不区分敌我
     - "敌方士兵"/"敌方单位" = 仅敌方
     - "友方士兵"/"你的单位" = 仅己方
     - "相邻单位" = 所有相邻，不区分敌我（除非前面有"敌方"/"友方"修饰）
     - **禁止凭"游戏常识"或"设计直觉"自行添加描述中不存在的限定条件**。如果实现者认为描述有歧义，必须向用户确认后再实现，禁止自行假设。

3. **代码语义验证**：逐个检查实现代码是否与描述语义一致

4. **测试语义验证**：检查测试是否按正确语义编写。**测试通过但语义错误 = 测试本身有 bug**，必须同时修复实现和测试

### 上下文角色反转场景（强制）

> 某些执行上下文会交换角色身份（如防御阶段中"攻击者"实际指防御者）。这是高频出错点——当 handler 和测试同时按直觉理解角色时，错误互相抵消，测试全部通过但实际运行时目标全部反转。

**审查方法**：
1. grep 所有涉及角色反转上下文的 handler，逐个验证角色字段使用是否与约定一致
2. 验证测试构建的上下文是否与运行时约定一致
3. **测试必须断言关键事件的目标 ID**（伤害打到谁、buff 给谁），不能只断言数量和数值

**适用时机**：新增涉及角色反转的效果时、修复"效果目标反了"类 bug 时。

---

## 测试覆盖要求（强制）

- **新增功能必须补充测试**：覆盖正常+异常场景
- **GameTestRunner 优先**：行为测试是最可靠的测试手段
- **契约测试补充**：批量覆盖注册表引用完整性和交互链完整性
- **端到端测试**：关键交互面必须有 E2E 覆盖

---

## 审计反模式清单（强制）

> 审查时逐条检查，来自实际遗漏复盘。

| # | 反模式 | 正确做法 | P |
|---|--------|----------|---|
| 1 | "可以/可选"效果自动执行，无玩家确认 | 触发事件 → UI 确认/跳过 → 独立命令执行 | P0 |
| 2 | 测试只断言事件发射，不验证 reduce 后状态 | 同时断言事件 + 最终状态 | P0 |
| 3 | `as any` 绕过类型检查访问不存在的字段 | 用正确类型或类型守卫 | P0 |
| 4 | 审计矩阵测试层标 ✅ 但只有事件断言 | 必须覆盖"命令→事件→状态变更"全链路 | P1 |
| 5 | 八层链路全 ✅ 但消费点绕过统一查询入口 | grep 原始字段访问，确认所有消费点走统一入口 | P0 |
| 6 | 只检查自身实体的属性查询，忽略对其他实体的查询 | 其他实体同样需要走统一查询入口 | P0 |
| 7 | 纵向审计通过就判定"已实现"，不做横向一致性检查 | 纵向（八层链路）+ 横向（数据查询一致性）双维度审查 | P1 |
| 8 | handler 元数据声明与实际输出事件类型不一致 | 注册元数据前确认 handler 所有输出事件类型；修改 handler 后同步更新 | P0 |
| 9 | 描述含限定条件但实现使用不携带约束的全局机制，限定条件仅在入口检查、执行时不约束 | 限定效果必须通过交互流程将约束固化在执行路径中，禁止"前置检查+全局额度"模式 | P0 |
| 10 | UI 层直接读底层字段显示数值，绕过统一查询入口 | 数据查询一致性审查的 grep 范围必须包含 UI 文件 | P0 |
| 11 | 效果实现语义与规则描述不一致，且测试按错误实现编写导致测试通过 | 实现前拆解描述语义，实现后逐条验证；测试 setup 必须反映正确语义；审查时对照规则描述逐动词验证 | P0 |
| 12 | "代替 X 做 Y"只实现了 Y 的效果，遗漏了消耗 X 的机会成本的状态变更 | "代替"拆解为两个原子操作：① 消耗被代替资源的机会 ② 执行替代效果。两者都必须有对应事件和 reduce。通用做法：在定义层声明代价字段，由执行入口自动发射消耗事件 | P0 |
| 13 | 新增需要玩家确认的 UI 交互状态但未注册到自动跳过守卫，导致等待玩家输入时阶段被自动跳过。当唯一能行动的实体已标记为"已行动"（额外行动命令尚未执行）时，可用行动判定也会返回 false，两个条件叠加触发自动跳过 | 新增任何交互等待状态后，必须将其加入自动跳过守卫的活跃交互判定。审查清单：grep 所有交互模式状态，逐个确认是否在守卫中 | P0 |
| 14 | 涉及角色反转的上下文中，handler 和测试同时按直觉理解角色身份，错误互相抵消——测试全部通过但实际运行时目标全部反转 | handler 必须按上下文约定使用角色字段；测试构建的上下文必须与运行时约定一致；测试必须断言关键事件的目标 ID | P0 |
| 15 | UI 层调用 `moves.xxx()` 使用了不存在的命令名（如 `moves.activateAbility` 而非 `moves[SW_COMMANDS.ACTIVATE_ABILITY]`），因 `Record<string, Function>` 类型不报错，`?.` 可选链静默跳过 | 禁止点号访问 moves 对象。所有 moves 调用必须通过命令常量表索引（`moves[COMMANDS.XXX]`）。框架层应提供类型安全的 moves 封装，将 `Record<string, Function>` 收窄为命令常量表的 value 联合类型 | P0 |
| 16 | 描述中作用目标无阵营限定词（如"士兵"/"单位"/"卡牌"），但实现自行添加了敌我过滤（如 `owner !== movingUnitOwner`），测试也按错误理解编写（`// 友方不算`），导致效果只对敌方生效 | 实现前必须对描述中每个名词做"语义边界锁定"：无限定词 = 不区分敌我/类型；有限定词（"敌方"/"友方"/"你的"）= 严格按限定过滤。**禁止实现者凭"常识"或"游戏直觉"自行添加描述中不存在的限定条件**。审查时逐个 filter/条件表达式回溯到权威描述，确认每个过滤条件都有描述依据。**教训**：踩踏"对每个被穿过的士兵造成 1 点伤害"——"士兵"无敌我限定，但实现加了 `owner !== movingUnitOwner` 只伤敌方，测试写了 `// 友方不算穿过`，语义错误被测试固化 | P0 |

# 审计规范缺口分析：神选者交互 UI 渲染问题

## 问题回顾

神选者的确认交互（"是否抽一张疯狂卡来获得+2力量？"）显示为基地卡牌图标而不是"是/否"按钮，导致用户困惑和可能的交互卡死。

## 为什么现有审计规范没有捕获这个问题？

### 1. 现有规范的覆盖范围

`docs/ai-rules/testing-audit.md` 中的 D1-D33 维度主要关注：

- **业务逻辑正确性**（D1-D10）：语义保真、边界完整、数据流闭环、查询一致性、交互完整、副作用传播、资源守恒、时序正确、幂等与重入、元数据一致
- **状态管理完整性**（D11-D20）：Reducer 消耗路径、写入-消耗对称、多来源竞争、回合清理完整、UI 状态同步、条件优先级、隐式依赖、否定路径、组合场景、状态可观测性
- **架构一致性**（D21-D33）：触发频率门控、伤害计算管线配置、架构假设一致性、Handler 共返状态一致性、MatchState 传播完整性、事件设计完整性、可选参数语义、白名单/黑名单完整性、PPSE 事件替换完整性、消灭流程时序与防止消灭白名单、效果拦截路径完整性、替代路径后处理对齐、跨实体同类能力实现路径一致性

### 2. 缺失的维度

**完全没有覆盖 UI 层的渲染逻辑**，特别是：
- 交互选项的 `displayMode` 声明
- UI 组件如何判断渲染模式（卡牌 vs 按钮）
- 选项 `value` 中的字段对 UI 渲染的影响
- UI 组件的自动推断逻辑与交互设计意图的一致性

### 3. 这个 bug 的特殊性

这个 bug 的特点是：
- ✅ **业务逻辑完全正确**：交互创建、处理器、状态更新都没问题
- ✅ **数据流闭环**：定义→注册→执行→状态都正确
- ✅ **功能完全可用**：点击"否"按钮可以正常响应
- ❌ **UI 渲染错误**：显示为基地图标而不是按钮，导致用户困惑

现有审计规范聚焦在"功能是否正确实现"，而不是"UI 是否正确显示"。

## 补充的审计维度

### D34：交互选项 UI 渲染模式正确性（强制）

**触发条件**：新增/修改任何创建交互选项的代码时触发

**核心问题**：UI 组件通过检测选项 `value` 中的特定字段（如 `defId`/`minionDefId`/`baseDefId`）来自动推断渲染模式。如果选项 `value` 中包含这些字段但实际不是"选择卡牌"的交互，UI 会误判并渲染错误的组件。

**审查方法**：

1. **识别交互类型**：
   - 简单确认交互："是/否" → 应该显示为按钮
   - 卡牌选择交互：从手牌/弃牌堆选择 → 应该显示为卡牌图标
   - 基地选择交互：选择一个基地 → 应该显示为基地卡牌图标

2. **检查 `value` 字段**：
   - 简单确认交互的 `value` **禁止包含** `defId`/`minionDefId`/`baseDefId` 字段
   - 检查交互处理器是否真的使用了 `value` 中的所有字段

3. **显式声明 `displayMode`**：
   - 简单确认交互必须显式声明 `displayMode: 'button'`

4. **验证 UI 渲染逻辑**：
   - 检查 `PromptOverlay.tsx` 中的 `isCardOption` 和 `extractDefId` 函数
   - 确认这些函数的判断逻辑与交互设计意图一致

## 为什么这个维度之前被忽略了？

### 1. 关注点偏差

开发过程中，我们更关注：
- "功能是否正确实现"（业务逻辑）
- "状态是否正确更新"（数据流）
- "测试是否通过"（功能验证）

而忽略了：
- "UI 是否按预期显示"（用户体验）
- "交互是否符合用户心智模型"（可用性）

### 2. 隐式假设

我们隐式假设：
- "只要业务逻辑正确，UI 就会正确显示"
- "UI 组件会自动处理各种情况"

但实际上：
- UI 组件有自己的判断逻辑（`isCardOption`/`extractDefId`）
- 这些判断逻辑可能与交互设计意图不一致
- 需要显式声明 `displayMode` 来避免误判

### 3. 测试盲区

现有测试主要验证：
- 交互是否被创建
- 交互处理器是否正确执行
- 状态是否正确更新

但没有验证：
- 交互选项的 `displayMode` 是否正确
- UI 实际渲染的组件类型是否符合预期

## 如何避免类似问题？

### 1. 补充审计规范

✅ 已完成：在 `docs/ai-rules/testing-audit.md` 中添加 D34 维度

### 2. 更新开发流程

新增/修改交互创建代码时，必须：
1. 识别交互类型（确认 vs 选择）
2. 检查 `value` 字段（移除不必要的字段）
3. 显式声明 `displayMode`
4. 编写测试验证 `displayMode` 和 UI 渲染

### 3. 代码审查清单

PR 审查时，检查：
- [ ] 简单确认交互是否声明了 `displayMode: 'button'`
- [ ] 选项 `value` 是否包含不必要的 `defId`/`minionDefId`/`baseDefId`
- [ ] 交互处理器是否使用了 `value` 中的所有字段
- [ ] 是否有测试验证 `displayMode` 正确

### 4. 防御性编程

在 UI 组件中添加更多防御性检查：
- 如果选项有 `displayMode`，优先使用显式声明
- 如果选项没有 `displayMode`，再使用自动推断
- 添加警告日志，提示开发者显式声明 `displayMode`

## 总结

这个 bug 暴露了现有审计规范的一个盲区：**UI 层的渲染逻辑**。虽然业务逻辑完全正确，但 UI 显示错误仍然会导致用户困惑和可用性问题。

通过添加 D34 维度（交互选项 UI 渲染模式正确性），我们补充了这个缺口，确保未来类似的问题能够被审计规范捕获。

**关键教训**：
1. 审计规范不仅要关注"功能是否正确"，还要关注"UI 是否正确显示"
2. UI 组件的自动推断逻辑可能与交互设计意图不一致，需要显式声明
3. 测试不仅要验证业务逻辑，还要验证 UI 渲染结果
4. 防御性编程：显式声明 > 隐式推断
